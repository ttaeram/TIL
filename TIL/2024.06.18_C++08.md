# Chapter 08: 상속과 다형성
## 객체 포인터의 참조 관계
### 객체의 주소 값을 저장하는 객체 포인터 변수
- C++에서 AAA형 포인터 변수는 AAA 객체 또는 AAA를 직접 혹은 간접적으로 상속하는 모든 객체를 가리킬 수 있음
- 객체의 주소 값을 저장할 수 있음
```cpp
class Student : public Person
{
  ...
};

class PartTimeStudent : public Student
{
  ...
};
```
- 아래 모두 가능
```
Person * ptr=new Student();
Person * ptr=new PartTimeStudent();
*Student * ptr=new PartTimeStudent();
```

### 유도 클래스의 객체도 가리키는 포인터
- IS-A 관계
  - 학생(Student)은 사람(Person)의 일종이다.
  - 근로학생(PartTimeStudent)은 학생(Student)의 일종이다.
  - 근로학생(PartTimeStudent)은 사람(Person)의 일종이다.
- 유도 클래스 객체를 기초 클래스 객체로 바라볼 수 있는 근거
  - 학생(Student)은 사람(Person)이다.
  - 근로학생(PartTimeStudent)은 학생(Student)이다.
  - 근로학생(PartTimeStudent)은 사람(Person)이다.

### 오렌지미디어 급여 관리 확장성 문제 1차 해결
- 고용인: Employee
- 정규직: PermanentWorker
- 영업직: SalesWorker
- 임시직: TemporaryWorker
- 정규직, 영업직, 임시직 모두 고용의 한 형태임(고용인이다)
- 영업직은 정규직의 일종임
- 모든 클래스의 객체를 Employee 클래스의 객체로 간주할 수 있는 기반을 마련
- 컨트롤 클래스 입장에서는 모든 객체를 Employee 객체로 간주해도 문제가 되지 않음

### EmployeeHandler의 첫번째 수정
```cpp
class EmployeeHandler
{
private:
  Employee* empList[50];
  int empNum;
public:
  EmployeeHandler() : empNum(0)
  {}
  void AddEmployee(Employee* emp)
  {
    empList[empNum++]*emp;
  }
  void ShowAllSalaryInfo() const
  {
    // for(int i=0; i<empNum; i++)
    //   empList[i]->ShowSalaryInfo();
  }
  void ShowTotalSalary() const
  {
    int sum=0;
    // for(int i=0; i<empNum; i++)
    //   sum+=empList[i]->GetPay();
    cout<<"salary sum: "<<sum<<endl;
  }
  ~EmployeeHandler()
  {
    for(int i=0; i<empNum; i++)
      delete empList[i];
  }
};

class Employee
{
private:
  char name[100];
public:
  Employee(char * name)
  {
    strcpy(this->name, name);
  }
  void ShowYourName() const
  {
    cout<<"name: "<<name<<endl;
  }
};

class PermanentWorker : public Employee
{
private:
  int salary;
public:
  PermanentWorker(char* name, int money)
    : Employee(name), salary(money)
  {}
  int GetPay() const
  {
    return salary;
  }
  void ShowSalaryInfo() const
  {
    ShowYourName();
    cout<<"slary: "<<GetPay()<<endl<<endl;
  }
};
```
- EmployeeHandler 클래스는 Employee 객체를 처리하는 컨트롤 클래스로 변경됨

### 임시직 TemporaryWorker
```cpp
class TemporaryWorker : public Employee
{
private:
  int workTime;
  int payPerHour;
public:
  TemporaryWorker(char * name, int pay)
    : Employee(name), workTime(0), payPerHour(pay)
  {}
  void AddWorkTime(int time)
  {
    workTime+=time;
  }
  int GetPay() const
  {
    return workTime*payPerHour;
  }
  void ShowSalaryInfo() const
  {
    ShowYourName();
    cout<<"salary: "<<GetPay()<<endl;
  }
};
```

### 영업직 SalesWorker
```cpp
class SalesWorker : public PermanentWorker
{
private:
  int salesResult;
  double bonusRatio;
public:
  SalesWorker(char * name, int money, double ratio)
    : PermanentWorker(name, money), salesResult(0), bonusRatio(ratio)
  {}
  void AddSalesResult(int value)
  {
    salesResult+=value;
  }
  // PermanentWorker 클래스의 GetPay 함수를 오버라이딩
  int GetPay() const
  {
    return PermanentWorker::GetPay()  // PermanentWorker의 GetPay 함수 호출
      + (int)(salesResult*bonusRatio);
  }
  // PermanentWorker 클래스의 ShowSalaryInfo 함수를 오버라이딩
  void ShowSalaryInfo() const
  {
    ShowYourName();
    cout<<"salary: "<<GetPay()<<endl<<endl; // SalesWorker의 GetPay 함수 호출
  }
}
```