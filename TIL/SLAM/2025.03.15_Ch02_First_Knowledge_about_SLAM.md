# Chapter 02: SLAM에 대한 첫번째 지식
## 01. 소개: 순무 로봇
- 우리는 순무 로봇이 시본적인 기능인 자율 이동 능력을 갖추기 바란다.
- 순무 로봇의 장비: 스테레오 카메라, 바퀴와 바퀴에 부착된 속도 센서, 무선 안테나, 노트북
- 바퀴가 있기에 움직일 수는 있지만, 효과적인 경로 계획과 탐색 시스템 및 제어가 없다면 순무는 행동의 목표가 어디인지 알지 못한다.
- 충돌을 피하고자 한다면 눈(카메라)가 있어야 한다.
- 따라서 순무가 방을 배회하려면 다음 2가지를 알아야 한다.
    1. 현재 위치: Localization, 위치 추정
    2. 주변 환경: Map building, 지도 작성
- 순무는 내부적으로는 자신의 상태와 동시에 외부적으로는 주변 환경을 이해해야 한다.

### 주변 환경을 인식할 수 있는 센서
1. 로봇 본채에 포함되어 이동하는 센서: 바퀴달린 엔코더, 카메라, 레이저 센서
2. 환경에 설치된 센서: 가이드 레일, QR 코드, GPS 수신기
- 환경에 설치된 센서는 수동적인 이유와, 갖은 제약 조건으로 보편적인 솔루션이 될 수 없다.
- SLAM의 정의에 의해 미지의 환경에서 작동해야 하므로 로봇 자체에 탑제된 센서를 이용해 매핑이 이루어져야 한다.

### 순무의 눈이 될 카메라
- 연속 비디오 스트림을 생성하기 위해 특정 프레임 속도로 주변 환경을 촬영한다.
- 일반 카메라는 초당 30 프레임, 고속 카메라는 더 빠르다.
단안 카메라: 하나의 카메라를 가진다.
- 스테레오 카메라: 두개의 카메라를 가진다.
- RGB-D 카메라: 컬러 사진을 캡쳐할 수 있고, 픽셀별로 카메라로부터 캡쳐 대상까지의 거리를 측정할 수 있다.

### 단안 카메라
- 단안 SLAM: SLAM을 위해 하나의 카메라만 사용하는 것
- 구조가 간단하고, 비용이 적게 든다.
- 단안 카메라의 데이터: 사진
- 장면의 피사체와 카메라 사이의 거리를 단일 이미지로는 얻을 수 없다.
- 3차원 구조를 복원하기 위해서는 카메라의 시야각을 바꿔야 한다.
- 카메라가 움직일 때 물체의 이미지 이동은 시차를 형성한다.
- 시차를 통해 우리는 어떤 물체가 멀리 떨어져 있고, 어떤 물체가 더 가까운지 정량적으로 결정할 수 있다.
- 단안 SLAM에 의해 추정된 궤적 및 지도가 스케일(Scale)이라는 요소에 의해 실제와 다를 것이다.
- 스케일 모호성: 단안 SLAM은 이미지만으로 실제 스케일을 결정할 수 없다.

### 스테레오 카메라
- 스테레오 카메라는 두 대의 단안 카메라로 구성된다.
- 이 두 카메라 사이의 거리를 사용하여 사람의 눈과 유사하게 각 픽셀의 공간적 위치를 추정한다.
- 이에 많은 계산이 요구되고, 성능은 인간과 비교했을 때 굉장히 서툴다.
- 기준선의 길이가 길수록 물체를 더 멀리 측정할 수 있으므로 무인 자동차의 양안 카메라는 클 수 밖에 없다.
- 스테레오 카메라는 다른 센싱 장치에 의존하지 않으 실내외 모두 적용 가능하다.
- 일반적으로 실시간 지도 생성을 위해 GPU나 FPGA를 이용한 가속이 필요하다.

### RGB-D 카메라
- 적외선 또는 ToF의 원리를 이용하여 물체와의 거리를 계산한다.
- 스테레오 카메라와 다르게 소프트웨어 계산으로 해결하는 것이 아닌 물리적인 측정 방식으로 해결한다.
- 실외에서 사용이 제한되는 이유:
    - 좁은 측정 범위
    - 높은 노이즈
    - 작은 화각
    - 태양광의 간섭
    - 투명한 물체의 측정 불가

## 02. 전형적인 Visual SLAM 프레임워크
- Visual SLAM 프로세스
1. 센서 정보를 읽는다.
    - Visual SLAM에서는 주로 카메라 이미지 정보를 읽고 전처리를 한다. 
    - 로봇의 경우 모터 엔코더 및 관성 센서와 같은 정보를 읽고 동기화할 수 있다.
2. Visual Odometry:
    - 시각정 주행거리 측정이라고도 하는데 인접한 이미지 사이의 카메라 움직임을 추정하고 대강의 로컬 맵을 생성하는 것이며, 프론트엔드라고도 한다.
3. Filters Optimization:
    - 비선형 최적화 과정으로, 서로 다른 시간에 VO로 측정한 카메라 포즈와 루프 백 감지 정보를 받아들이고 최적화하여, 전역적으로 일관된 궤적과 지도를 얻는 것을 말한다. 
    - VO 뒤에 연결되기 때문에 백엔드라고도 한다.
4. Loop Closing:
    - 루프 백 감지라고 하며, 로봇이 이전에 도달했던 위치에 다시 왔는지 여부를 결정한다.
    - 루프 백이 감지되면 더 나은 최적화 처리를 위해 정보를 백엔드에 제공한다.
5. Reconstruction:
    - 매핑 즉, 맵을 만드는 과정으로 추정된 카메라의 궤적을 기반으로 임무 요구사항에 해당하는 맵을 구축하는 것을 말한다.

### Visual Odometry
- 시각정 주행거리 측정 (VO)
- 인접한 이미지 간의 카메라 움직임을 고려하는 것이다.
- 가장 간단한 경우는 두 이미지 간의 움직임 관계이다.
- 두 이미지 사이의 회전 각도와 평행 이동한 크기를 결정할 수 있는가에 대답은 하기 어렵다.
- 카메라의 움직임을 정량적으로 추정하기 위해서는 먼저 카메라의 공간적 점 사이의 기하학적 관계에 대한 이해가 필요하다.
- 우리는 VO가 인접한 프레임 사이의 이미지에서 카메라 움직임을 추정하고 장면의 공간 구조를 복구할 수 있다는 사실을 알 수 있다.
- 실제 주행거리 측정계와 마찬가지로 인접한 순간의 움직임만 계산하고 과거 정보와 상관관계가 없으므로 "주행 거리계"라고 하는 것이다.
- VO는 단기기억만 있다.
- 연속된 두 이미지 사이의 카메라 움직임을 추정하는 VO가 있다고 가정하자.
- 그 인접한 움직임을 연결할 수 있는 자연스러운 로봇의 궤적이 형성된다면 위치 추정 문제가 해결된다.
- 매 순간 카메라의 위치에 따라 각 픽셀에 해당하는 3차원 공간 상의 점의 위치를 계산할 수 있다면 우리는 지도를 얻을 수 있다.
- VO만으로 궤적을 추정하는 것은 필연적으로 축적된 누적 오차로 이어질 것이다.
- 사소한 오차가 발생하더라도 누적되면 걷잡을 수 없이 커지게 된다.
- 이러한 현상을 드리프트(Drift)라고 하며 일관된 지도를 구축하는데 방해가 된다.
- 이를 해결하기 위해 백엔드 최적화와 루프 백 감지가 필요하다.

### 백엔드 최적화
- 주로 SLAM 프로세스에서 노이즈 문제를 처리하는 것을 말한다.
- 이미지에서 카메라 움직임을 추정하는 방법을 해결하는 것 외에도 이 추정치가 얼마나 노이즈가 많은지 이 노이즈가 어느 한순간에서 다음 순간으로 어떻게 전달되는지 현재 추정치의 신뢰도가 얼마나 큰지에 대해서도 관심을 둔다.
- 고려해야 할 문제는 잡음이 있는 데이터에서 전체 시스템의 상태를 추정하는 방법과 상태 추정이 얼마나 불확실한가이다.
- 이를 사후 확률 추정이라고 한다.
- SLAM 프레임워크에서는 프론트엔드는 백엔드에 최적화할 데이터와 이러한 데이터의 초깃값을 제공하낟.
- 백엔드는 데이터만 마주하는 경우가 많으며 데이터가 어느 센서에서 오는지는 중요치 않다.
- SLAM 문제의 본질은 움직이고 있는 카메라와 주변 환경의 공간적 불확실성 추정이라고 할 수 있다.

### 루프 백 감지
- 주로 시간 경과에 따른 위치 추정의 드리프트 문제를 해결한다.
- 일정 시간 이후 원점으로 돌아왔을 때 드리프트로 인해 위치 추정치가 원점으로 돌아오지 않는 현상을 말한다.
- 로봇이 "원점"을 식별할 방법이 있다면 위치 추정치를 원덤으로 "끌어오는 것"으로 드리프트를 제거할 수 있을 것이다.
- 루프 백 감지는 "위치" 및 "맵 빌딩"과 밀접한 관련이 있다.
- 카메라 이미지 자체만으로 수행할 수 있어야 한다.
- 이미지 간의 유사성을 판단하여 수행할 수 있다.

### 매핑
- 지도를 만드는 과정을 의미한다.
- 카메라의 경우 6 자유도의 움직임과 최소한 3차원 지도가 필요하다.
- 지도를 구성할 때 3차원 공간 위 점들의 집합 뿐만 아니라 그 위에 입혀질 텍스쳐 정보까지도 원한다.
- 또한 지도가 어떻게 생겼는지 신경쓰지 않고 "A에서 B로 가는 것은 가능하지만 B에서 C로 가는 것은 불가능하다" 하는 것과 같은 정보를 알고 있어야 할 때도 있다.
- 이와 같은 환경에 대한 이해를 토폴로지 방법이라고 한다.
- 예를 들어 자율 주행 차량의 경우 주변 지도와 상관없이 차선에 대한 정보만으로 운행되는 경우를 말한다.

#### 1. 메트릭 맵 (Metric Map)
- 지도에서 객체의 위치 관계를 정확하게 나타내는 것을 강조하며, 일반적으로 희소(Sparse)와 조밀(Dense)로 분류된다.
- 희소맵: 특정 수준의 추상화를 제공하며 모든 개체를 나타낼 필요가 없는 지도
- 조밀맵: 보이는 모든 것을 모델링하는데 중점을 둔 지도
- 조밀맵은 일반적으로 특정 해상도에 따라 많은 작은 그리드로 구성되며 3차원 메트릭 맵에서는 많은 작은 사각형인 복셀로 표현된다.

#### 2. 토폴로지 맵 (Topologicla Map)
- 지도 요소 간의 관계를 강조한다.
- 노드와 에지로 구성된 그래프로, 노드 간의 연결성만 고려한다.
- 지도의 세부 정보를 제거하여 복잡한 구조의 맵을 잘 표현하지는 못한다.

## 03. SLAM 문제의 수학적 공식화

## 04. 실습: 프로그래밍의 기초
### Linux 운영 체제를 설치
- 사용할 프로그램은 주로 Linux의 C++ 프로그램이고, 실험 중에 많은 라이브러리를 사용한다.
- 대부분의 라이브러리는 Linux에 대한 더 나은 지원을 제공한다.
- 본 책에서는 우분투 22.04 버전을 사용할 것이다.
- 쉬운 방법은 가상 머신을 사용하는 것이지만, 원활한 상태를 유지하기 위해 4GB 이상의 메모리와 CPU가 필요하다.
- 실습을 위해 소스코드를 다운받아 `slambook2/ch2` 폴더로 가보자.

### Hello SLAM
- Linux에서 프로그램은 실행 권한이 있는 파일이다.
- 스크립트 또는 바이너리일 수 있지만 접미사 이름을 한정하지 않는다.
- C++ 프로그래밍을 사용할 때 먼저 텍스트 파일을 작성해 보자.
```cpp
// slamutrm/ch2/helloSLAM.cpp

#include <iostream>
using namespace std;

int main(int argc, char **argv) {
    cout << "Hello SLAM!" << endl;
    return 0;
}
```

- 이후 컴파일러라는 프로그램을 사용하여 텍스트 파일을 실행할 수 있는 프로그램으로 컴파일한다.
- 컴파일러 g++을 사용하여 실행 파일로 컴파일한다.

```
utrm@myubuntu:~/slambook2/slamutrm/ch2$ sudo apt install g++
utrm@myubuntu:~/slambook2/slamutrm/ch2$ g++ helloSLAM.cpp
```
- 이 명령이 잘 작동하면 출력이 없어야 한다.
- 이 명령은 c++ 파일을 실행 파일로 컴파일한다.
- 현재 디렉토리를 검사하면 `a/out` 파일이 하나 있고 실행 권한이 있음을 알 수 있다.
```
utrm@myubuntu:~/slambook2/slamutrm/ch2$ ./a.out
Hello SLAM!
```

### `cmake`를 사용하기
- 이론적으로 모든 C++ 프로그램은 g++로 컴파일 가능하다.
- 프로그램이 커질 때 많은 폴더와 소스파일이 있을 수 있으며, 컴파일 명령을 입력하는 것이 점점 길어질 것이다.
- 일반적으로 작은 C++ 프로젝트에는 복잡한 종속성이 있는 12개 이상의 많은 클래스가 포함될 수 있다.
- `cmake` 프로젝트에서는 `cmake` 명령을 사용하여 `makefile` 파일을 생성한 다음, `make` 명령을 통해 파이르이 내용을 기반으로 전체 프로젝트를 컴파일한다.
```
// slamutrm/ch2/CMakeLists.txt

# 선언에서 요청한 cmake 최소 버전
cmake_minimum_required( VERSION 2.8 )

# cmake 프로젝트 선언
project( HelloSLAM )

# 실행 파일 추가
# 문법 add_executable( 프로그램 이름 소스코드 파일 )
add_executble( helloSLAM HelloSLAM )
```
- `cmake`가 위 텍스트파일을 기반으로 수행하게된다.
```
utrm@myubuntu:~/slambook2/slamutrm/ch2$ cmake .
utrm@myubuntu:~/slambook2/slamutrm/ch2$ make
[ 50%] Building CXX object CMakeFiles/helloSLAM.dir/helloSLAM.cpp.o
[100%] Linking CXX executable helloSLAM
[100%] Built target helloSLAM
utrm@myubuntu:~/slambook2/slamutrm/ch2$ ./helloSLAM
Hello SLAM!
```
- 이제 이 프로세스에서 유일한 불만은 `cmake`에서 생성된 중간 파일이 코드 파일에 남아 있다는 것이다.
- 따라서 중간 파일을 컴파일이 성공하면 삭제할 수 있는 중간 디렉토리에 배치한다.
- `cmake` 프로젝트를 컴파일하는 더 일반적인 방법은 아래와 같다.
```
utrm@myubuntu:~/slambook2/slamutrm/ch2$ mkdir build
utrm@myubuntu:~/slambook2/slamutrm/ch2$ cd build
utrm@myubuntu:~/slambook2/slamutrm/ch2$ cmake ..
utrm@myubuntu:~/slambook2/slamutrm/ch2$ make
```
- 이 방법을 이용하면 중간파일이 소스코드와 별도로 build 폴더에 생성되므로 소스코드를 게시할 때 build 폴더를 삭제하기만 하면 된다.

### 라이브러리 사용
- C++ 프로젝트의 모든 코드가 실행 파일로 컴파일되는 것은 아니다.
- `main` 함수가 있는 파일만 실행 프로그램을 생성한다.
- 라이브러리: 다른 코드는 다른 프로그램에서 호출할 수 있도록 한 가지로 패키징한다.
- 라이브러리는 종종 많은 알고리즘과 프로그램의 모음이다.
```cpp
// slamutrm/ch2/libHelloSLAM.cpp

#include <iostream>
using namespace std;

void printHello() {
    cout << "Hello SLAM" << endl;
}
```
- 이 라이브러리는 정보를 출력하기 위해 호출되는 `printHello` 함수를 제공한다.
- 하지만 `main` 함수가 없으므로 라이브러리에 실행 파일이 없다.
- `CMakeLists.txt`에 아래 내용을 추가하자.
```
add_library( hello libHelloSLAM.cpp )
```
```
utrm@myubuntu:~/slambook2/slamutrm/ch2$ cd build
utrm@myubuntu:~/slambook2/slamutrm/ch2$ cmake ..
utrm@myubuntu:~/slambook2/slamutrm/ch2$ make
```
- 이 시점에서 `libHello.a`파일이 build 폴더에 생성되며, 이 파일은 우리가 얻은 라이브러리이다.
- 리눅스에서 라이브러리 파일은 정적 라이브러리와 공유 라이브러리로 나뉜다.
- 정적 라이브러리는 `.a` 접미사 이름으로, 공유 라이브러리는 `.so`로 끝난다.
- 모든 라이브러리는 패키징된 함수의 컬렉션이며 정적 라이브러리는 호출될때마다 복사본을 생성하는 반면, 공유 라이브러리는 복사본이 하나로, 공간이 적다.
- 정적 라이브러리 대신 공유 라이브러리를 생성하려면 아래의 명령문을 사용한다.
```
// slamutrm/ch2/CMakeLists.txt

add_library( hello_shared SHARED libHelloSLAM.cpp )
```