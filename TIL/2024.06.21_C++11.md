# Chapter 11: 연산자 오버로딩 02
## 반드시 해야 하는 대입 연산자의 오버로딩
### 객체 간 대입 연산의 비밀: 디폴트 대입 연산자
- 복사 생성자의 호출
```cpp
int main(void)
{
  Point pos1(5, 7);
  Point pos2=pos1;
  ...
}
```
- 대입 연산자의 호출
```cpp
int main(void)
{
  Point pos1(5, 7);
  Point pos2(9, 10);
  pos2=pos1;
  ...
}
```
- 멤버 대 멤버의 복사를 진행하는 디폴트 대입 연산자 삽입
```cpp
class First
{
private:
  int num1, num2;
public:
  First(int n1=0, int n2=0) : num1(n1), num2(n2)
  {}
  void ShowData()
  {
    cout<<num1<<", "<<num2<<endl;
  }
}
```
- First 클래스의 디폴트 대입 연산자
```cpp
First& operator=(const First& reef)
{
  num1=ref.num1;
  num2=ref.num2;
  return *this;
}
```

### 디폴트 대입 연산자의 문제점
- 이전에 공부한 디폴트 복사 생성자의 문제점과 동일한 문제점
- 메모리의 누수를 막기 위해 메모리 해제 연산 필요

### 상속 구조에서의 대입 연산자 호출
```cpp
class First
{
private:
  int num1, num2;
public:
  First(int n1=0, int n2=0) : num1(n1), num2(n2)
  {}
  void ShowData()
  {
    cout<<num1<<", "<<num2<<endl;
  }

  First& operator=(const First& reef)
  {
    cout<<"First& operator=()"<<endl;
    num1=ref.num1;
    num2=ref.num2;
    return *this;
  }
}

class Second : public First
{
private:
  int num3, num4
public:
  Second(int n1, int n2, int n3, int n4)
    : First(n1, n2), num3(n3), num4(n4)
  {}
  void ShowData()
  {
    First::ShowData();
    cout<<num3<<", "<<num4<<endl;
  }
}
```
- 디폴트 대입 연산자는 기초 클래스의 대입연산자를 호출해줌
- 그러나 명시적으로 대입 연산자를 정의하게 되면 기초 클래스의 대입 연산자 호출도 아래와 가팅 별도로 명시해야 함
```cpp
Second& operator=(const Second& ref)
{
  cout<<"Second& operator=()"<<endl;
  First::operator=(ref);
  num3=ref.num3;
  num4=ref.num4;
  return *this;
}
```

### 이니셜라이저의 성능 향상 도움
```cpp
class BBB
{
private:
  AAA mem;
public:
  BBB(const AAA& ref) : mem(ref)
  {}
};

class CCC
{
private:
  AAA mem;
public:
  CCC(const AAA& ref)
  {
    mem=ref;
  }
};

int main(void)
{
  AAA obj1(12);
  cout<<"**********"<<endl;
  BBB obj2(obj1);
  cout<<"**********"<<endl;
  CCC obj3(obj1);
  return 0;
}
```
```
실행 결과

AAA(int n=0)
**********
AAA(const AAA& ref)
**********
AAA(int n=0)
operator=(const AAA& ref)
```
- 이니셜라이저를 이용해서 멤버를 초기화하면, 함수호출의 수를 1회 줄일 수 있음