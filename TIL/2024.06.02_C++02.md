# Chapter 02: C언어 기반의 C++
## Chapter 02 시작에 앞서서
### C언어의 복습을 유도하는 확인학습
#### Q1 키워드 const의 의미
- 키워드 const는 어떠한 의미를 갖는가
1. `const int num=10;`
  - 변수 num을 상수화
2. `const int * ptr1=&val1;`
  - 포인터 ptr1을 이용해서 val1의 값을 변경할 수 있음
3. `int * const ptr2=&val2;`
  - 포인터 ptr2가 상수화 됨
4. `const int * const ptr3=&val3;`
  - 포인터 ptr3가 상수화 되었으며, ptr3를 이용해서 val3의 값을 변경할 수 있음

#### Q2 실행 중인 프로그램의 메모리 공간
- 실행 중인 프로그램은 운영체제로부터 메모리 공간을 할당 받는데, 이는 크게 데이터, 스택, 힙 영역으로 나뉨
- 각각의 영역에는 어떠한 형태의 변수가 할당되는가
- 특히 C언어의 malloc과 free 함수와 관련해서도 설명하라
  - 데이터: 전역변수가 저장되는 영역
  - 스택: 지역변수 및 매개변수가 저장되는 영역
  - 힙: malloc 함수 호출에 의해 프로그램이 실행되는 과정에서 동적으로 할당이 이뤄지는 영역
  - malloc & free: malloc 함수호출에 의해 할당된 메모리 공간은 free 함수호출을 통해서 소멸하지 않으면 해제되지 않음

#### Q3 Call-by-value vs Call-by-reference
- 함수의 호출형태는 크게 '값에 의한 호출(Call-by-value)'과 '참조에 의한 호출(Call-by-reference)'로 나뉨
- 이 둘을 나누는 기준이 무엇인지, 두 int 형 변수의 값을 교환하는 Swap 함수를 예로 들어가면서 설명하라
```cpp
void SwapByValue(int num1, int num2)
{
  int temp=num1;
  num1=num2;
  num2=temp
} // Call-by-value

void SwapByRef(int * ptr1, int * ptr2)
{
  int temp=*ptr1;
  *ptr1=*ptr2;
  *ptr2=temp;
} // Call-by-reference
```

## 새로운 자료형 Bool
### '참'을 의미하는 true와 '거짓'을 의미하는 false
```cpp
int main(void)
{
  int num=10;
  int i=0;
  cout<<"true: "<<true<<endl;
  cout<<"false: "<<false<<endl;
  while(true)
  {
    cout<<i++<<' ';
    if(i>num)
      break;
  }
  cout<<endl;
  cout<<"sizeof 1: "<<sizeof(1)<<endl;
  cout<<"sizeof 0: "<<sizeof(0)<<endl;
  cout<<"sizeof true: "<<sizeof(true)<<endl;
  cout<<"sizeof false: "<<sizeof(false)<<endl;
  return 0;
}
```
```
실행 결과

true: 1
false: 0
0 1 2 3 4 5 6 7 8 9 10
sizeof 1: 4
sizeof 0: 4
sizeof true: 1
sizeof false: 1
```
- **true**는 '참'을 의미하는 1바이트 데이터이고, **false**는 '거짓'을 의미하는 1바이트 데이터임
- 이 둘은 각각 정수 1과 0이 아님
- 그러나 정수가 와야 할 위치에 오게 되면 각각 1과 0으로 변환됨
- `int num1=true;`: num1에는 1이 저장됨
- `int num2=false;`: num2에는 0이 저장됨
- `int num3=true+false;`: num3=1+0;

### 자료형 bool
#### bool의 이해
- true와 false는 bool형 데이터임
- true와 false 정보를 저장할 수 있는 변수는 bool형 변수임
  - `bool isTrueOne=true;`
  - `bool isTrueTwo=false;`
```cpp
bool IsPositive(int num)
{
  if(num<0)
    return false;
  else
    return true;
}

int main(void)
{
  bool isPos;
  int num;
  cout<<"Input number: ";
  cin>>num;
  isPos=IsPositive(num);
  if(isPos)
    cout<<"Positive number"<<endl;
  else
    cout<<"Negative number"<<endl;
  return 0;
}
```
```
실행결과

Input number: 12
Positive number
```

## 참조자의 이해
### 참조자(Reference)의 이해
- `int num1=2010;`:  변수의 선언으로 인해서 num1이라는 이름으로 메모리 공간이 할당됨
- `int &num2=num1;`: 참조자의 선언으로 인해서 num1의 메모리 공간에 num2라는 이름이 추가로 붙게 됨
- 참조자는 기존에 선언된 변수에 붙이는 별칭임
- 이렇게 참조자가 만들어지면 이는 변수의 이름과 사실상 차이가 없음

### 참조자 관련 예제와 참조자의 선언
```cpp
int main(void)
{
  int num1=1020;
  int &num2=num1;
  num2=3047;
  cout<<"VAL: "<<num1<<endl;
  cout<<"REF: "<<num2<<endl;
  cout<<"VAL: "<<&num1<<endl;
  cout<<"REF: "<<&num2<<endl;
  return 0;
}
```
- num2는 num1의 참조자임, 따라서 이후부터는 num1으로 하는 모든 연산은 num2로 하는 것과 동일한 결과를 보임
```
실행결과

VAL: 3047
REF: 3047
VAL: 0012FF60
REF: 0012FF60
```
- 참조자의 수에는 제한이 없으며 참조자를 대상으로 참조자를 선언하는 것도 가능함
```cpp
int num1=2759;
int &num2=num1;
int &num3=num2;
int &num4=num3;
```

### 참조자의 선언 가능 범위
- 불가능한 참조자의 선언의 예
  - `int &ref=20;`: 상수 대상으로의 참조자 선언은 불가능함
  - `int &ref;`: 참조자는 생성과 동시에 누군가를 참조해야 함
  - `int &ref=NULL;`: 포인터처럼 NULL로 초기화하는 것도 불가능함
- 참조자는 선언과 동시에 누군가를 참조해야하는데 그 참조의 대상은 기본적으로 변수가 되어야 함
- 참조자는 참조의 대상을 변경할 수 없음
- 변수의 성향을 지니는 대상이라면 참조자의 선언이 가능함
- 배열의 요소 역시 변수의 성향을 지니기 때문에 참조자의 선언이 가능함
```cpp
int main(void)
{
  int arr[3]={1, 3, 5};
  int &ref1=arr[0];
  int &ref2=arr[1];
  int &ref3=arr[2];
  cout<<ref1<<endl;
  cout<<ref2<<endl;
  cout<<ref3<<endl;
  return 0;
}
```
```
실행결과

1
3
5
```

### 포인터 변수 대상의 참조자 선언
```cpp
int main(void)
{
  int num=12;
  int *ptr=&num;
  int **dptr=&ptr;

  int &ref=num;
  int *(&pref)=ptr;
  int **(&dpref)=dptr;

  cout<<ref<<endl;
  cout<<*pref<<endl;
  cout<<**dpref<<endl;
  return 0;
}
```
- ptr과 dptr 역시 변수지만 주소 값을 저장하는 포인터 변수일 뿐임
- 따라서 위처럼 참조자의 선언이 가능
```
실행결과

12
12
12
```

## 참조자와 함수
### Call-by-value & Call-by-reference
```cpp
void SwapByValue(int num1, int num2)
{
  int temp=num1;
  num1=num2;
  num2=temp;
} // Call-by-value
```
- 값을 전달하면서 호출하게 되는 함수이므로 이 함수는 Call-by-value
- 이 경우 함수 외에 선언된 변수에는 접근이 불가능

```cpp
void SwapByRef(int * ptr1, int * ptr2)
{
  int temp=*ptr1;
  *ptr1=*ptr2;
  *ptr2=temp;
} // Call-by-reference
```
- 값은 값이되 주소 값을 전달하면서 호출하게 되는 함수이므로 이 함수는 Call-by-reference
- 이 경우 인자로 전달된 주소의 메모리 공간에 접근이 가능
