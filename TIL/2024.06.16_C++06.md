# Chapter 06: Friend와 Static 그리고 Const
## Const와 관련해서 아직 못다한 이야기
### Const와 관련해서 아직 못다한 이야기
```cpp
class SoSimple
{
private:
  int num;
public:
  SoSimple(int n) : num(n)
  {}
  SoSimple AddNum(int n)
  {
    num+=n;
    return *this;
  }
  void ShowData() const
  {
    cout<<"num: "<<num<<endl;
  }
};

int main(void)
{
  const SoSimple obj(7);  // 이 객체의 데이터 변경을 허용하지 않음
  // obj.AddNum(20);
  obj.ShowData();
  return 0;
}
```
- const로 선언된 객체를 대상으로는 const로 선언 되지 않는 멤버함수의 호출이 불가능함

### const와 함수 오버로딩
```cpp
class SoSimple
{
private:
  int num;
public:
  SoSimple(int n) : num(n)
  {}
  SoSimple& AddNum(int n)
  {
    num+=n;
    return *this;
  }
  void SimpleFunc()
  {
    cout<<"SimpleFunc: "<<num<<endl;
  }
  void SimpleFunc() const
  {
    cout<<"const SimpleFunc: "<<num<<endl;
  }
};

void YourFunc(const SoSimple &obj)
{
  obj.SimpleFunc();
}

int main(void)
{
  SoSimple obj1(2);
  const SoSimple obj2(7);
  obj1.SimpleFunc();
  obj2.SimpleFunc();
  YourFunc(obj1);
  YourFunc(obj2);
  return 0;
}
```
```
실행 결과

SimpleFunc: 2
const SimpleFunc: 7
const SimpleFunc: 2
const SimpleFunc: 7
```
- 함수의 const 선언 유무는 함수 오버로딩의 조건이 됨
- const 객체 또는 참조자를 대상으로 멤버함수 호출 시 cons 선언된 멤버함수가 호출됨