# Chapter 03: 클래스의 기본
## C++에서의 구조체
### C++에서의 구조체
- 구조체의 등장배경
  - 연관 있는 데이터를 하나로 묶으면 프로그램의 구현 및 관리가 용이함
  - 구조체는 연관 있는 데이터를 하나로 묶는 문법적 장치임
- 연관 있는 데이터들은 생성 및 소멸의 시점이 일치함
- 이동 및 전달의 시점 및 방법이 일치함
- 따라서 하나의 자료형으로 묶어서 관리하는 것이 용이

### C++에서의 구조체 변수 선언
- C 스타일 구조체 변수 초기화 -> C++ 스타일 구조체 변수 초기화
  - `struct Car basicCar;` -> `Car basicCar;`
  - `struct Car simpleCar;` -> `Car simpleCar;`
  - 따라서 C++에서는 구조체 변수 선언시 struct 키워드의 생략을 위한 typedef 선언이 불필요함

- Car 관련된 연관된 데이터들의 모임
```cpp
struct Car
{
  char gamerID[ID_LEN]; // 소유자 ID
  int fuelGauge;        // 연료량
  int curSpeed;         // 현재 속도
};
```
- Car 관련된 연관된 함수들의 모임
```cpp
void showCarState(const Car &car)
{
  ...
}

void Accel(Car &car)
{
  ...
}

void Break(Car &car)
{
  ...
}
```
- 데이터뿐만 아니라 해당 데이터와 연관된 함수들도 함께 그룹을 형성하기 때문에 함수도 하나로 묶는 것에 대해 나름의 가치를 부여할 수 있음

### 구조체 안에 함수 삽입하기
```cpp
struct Car
{
  char gamerID[ID_LEN];
  int fuelGuage;
  int curSpeed;

  void showCarState()
  {
    ...
  }

  void Accel()
  {
    ...
  }

  void Break()
  {
    ...
  }
};
```
- C++에서는 구조체 안에 함수를 삽입하는 것이 가능
- 따라서 C++에서는 구조체가 아닌 클래스라고 함
```cpp
void showCarState()
{
  cout<<"소유자ID: "<<gamerID<<endl;
  cout<<"연료량: "<<fuelGuage<<"%"<<endl;
  cout<<"현재속도: "<<curSpeed<<"km/s"<<endl;
}
```
```cpp
void Break()
{
  if(curSpeed<BRK_STEP)
  {
    curSpeed=0;   // 위에 선언된 curSpeed에 접근
    return 0;
  }
  curSpeed-=BRK_STEP;
}
```
- 함께 선언된 변수에는 직접 접근이 가능

### C++에서의 구조체 변수 선언
- 변수의 생성
```cpp
Car run99={"run99", 100, 0};
Car sped77={"sped77", 100, 0};
```
- 실제로는 구조체 변수마다 함수가 독립적으로 존재하는 구조가 아님
- 그러나 논리적으로는 독립적으로 존재하는 형태로 보아도 문제가 없음

### 구조체 안에 enum 상수의 선언